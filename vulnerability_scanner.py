
import requests
import re
import json
import ssl
import socket
import subprocess
from urllib.parse import urljoin, urlparse, parse_qs
from bs4 import BeautifulSoup
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import hashlib
import base64
from datetime import datetime
import os
import urllib3
from urllib3.exceptions import InsecureRequestWarning

# Desabilitar warnings SSL
urllib3.disable_warnings(InsecureRequestWarning)

class ProfessionalVulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
            'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8,en-US;q=0.7',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Cache-Control': 'max-age=0'
        })
        self.vulnerabilities = []
        self.security_headers = {}
        self.ssl_info = {}
        self.open_ports = []
        self.exposed_files = []
        self.sql_injection_vulns = []
        self.xss_vulns = []
        self.csrf_vulns = []
        self.directory_listing = []
        self.sensitive_data = []
        self.api_endpoints = []
        self.admin_panels = []

    def comprehensive_vulnerability_scan(self, url):
        """Scanner completo de vulnerabilidades"""
        print(f"🔍 Iniciando varredura completa de vulnerabilidades para: {url}")

        results = {
            "target_url": url,
            "scan_timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "domain_info": {},
            "ssl_analysis": {},
            "security_headers": {},
            "exposed_files": [],
            "directory_listing": [],
            "sql_injection": [],
            "xss_vulnerabilities": [],
            "csrf_vulnerabilities": [],
            "admin_panels": [],
            "api_endpoints": [],
            "sensitive_data": [],
            "port_scan": [],
            "technology_stack": {},
            "cms_detection": {},
            "vulnerability_summary": {},
            "risk_score": 0,
            "recommendations": []
        }

        try:
            # 1. Análise de domínio e DNS
            print("🌐 Analisando informações do domínio...")
            results["domain_info"] = self._analyze_domain(url)

            # 2. Análise SSL/TLS
            print("🔒 Verificando configurações SSL/TLS...")
            results["ssl_analysis"] = self._analyze_ssl(url)

            # 3. Análise de headers de segurança
            print("🛡️ Verificando headers de segurança...")
            results["security_headers"] = self._analyze_security_headers(url)

            # 4. Detecção de tecnologias
            print("🔧 Detectando stack de tecnologias...")
            results["technology_stack"] = self._detect_technologies(url)

            # 5. Detecção de CMS
            print("📝 Detectando CMS e versões...")
            results["cms_detection"] = self._detect_cms(url)

            # 6. Busca por arquivos expostos
            print("📁 Buscando arquivos sensíveis expostos...")
            results["exposed_files"] = self._scan_exposed_files(url)

            # 7. Verificação de directory listing
            print("📂 Verificando directory listing...")
            results["directory_listing"] = self._check_directory_listing(url)

            # 8. Teste de SQL Injection
            print("💉 Testando SQL Injection...")
            results["sql_injection"] = self._test_sql_injection(url)

            # 9. Teste de XSS
            print("🔴 Testando XSS...")
            results["xss_vulnerabilities"] = self._test_xss(url)

            # 10. Teste de CSRF
            print("🔄 Testando CSRF...")
            results["csrf_vulnerabilities"] = self._test_csrf(url)

            # 11. Busca por painéis administrativos
            print("👤 Buscando painéis administrativos...")
            results["admin_panels"] = self._scan_admin_panels(url)

            # 12. Descoberta de APIs
            print("🔌 Descobrindo endpoints de API...")
            results["api_endpoints"] = self._discover_api_endpoints(url)

            # 13. Busca por dados sensíveis
            print("🔍 Buscando dados sensíveis...")
            results["sensitive_data"] = self._scan_sensitive_data(url)

            # 14. Port scanning (limitado)
            print("🌐 Verificando portas comuns...")
            results["port_scan"] = self._scan_common_ports(url)

            # 15. Calcular score de risco
            print("📊 Calculando score de risco...")
            results["risk_score"], results["vulnerability_summary"] = self._calculate_risk_score(results)

            # 16. Gerar recomendações
            print("💡 Gerando recomendações de segurança...")
            results["recommendations"] = self._generate_recommendations(results)

            print("✅ Varredura completa finalizada!")
            return results

        except Exception as e:
            print(f"❌ Erro na varredura: {e}")
            return {"error": f"Erro na análise: {str(e)}"}

    def _analyze_domain(self, url):
        """Análise de informações do domínio"""
        domain_info = {}
        try:
            parsed = urlparse(url)
            domain = parsed.netloc

            # Informações básicas
            domain_info["domain"] = domain
            domain_info["scheme"] = parsed.scheme
            domain_info["port"] = parsed.port or (443 if parsed.scheme == 'https' else 80)

            # Tentar resolver DNS
            try:
                import socket
                ip = socket.gethostbyname(domain)
                domain_info["ip_address"] = ip
                domain_info["dns_resolution"] = "Success"
            except:
                domain_info["dns_resolution"] = "Failed"

            # Verificar redirecionamentos
            try:
                response = self.session.get(url, allow_redirects=False, timeout=10)
                if response.status_code in [301, 302, 303, 307, 308]:
                    domain_info["redirects"] = True
                    domain_info["redirect_location"] = response.headers.get('Location', '')
                else:
                    domain_info["redirects"] = False
            except:
                domain_info["redirects"] = "Unknown"

        except Exception as e:
            domain_info["error"] = str(e)

        return domain_info

    def _analyze_ssl(self, url):
        """Análise SSL/TLS"""
        ssl_info = {}
        try:
            parsed = urlparse(url)
            if parsed.scheme == 'https':
                hostname = parsed.netloc
                port = parsed.port or 443

                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE

                with socket.create_connection((hostname, port), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        cert = ssock.getpeercert()

                        ssl_info["certificate_valid"] = True
                        ssl_info["issuer"] = dict(cert.get('issuer', []))
                        ssl_info["subject"] = dict(cert.get('subject', []))
                        ssl_info["version"] = cert.get('version')
                        ssl_info["not_before"] = cert.get('notBefore')
                        ssl_info["not_after"] = cert.get('notAfter')
                        ssl_info["protocol"] = ssock.version()
                        ssl_info["cipher"] = ssock.cipher()

                        # Verificar se o certificado expira em breve
                        from datetime import datetime, timedelta
                        try:
                            not_after = datetime.strptime(cert.get('notAfter'), '%b %d %H:%M:%S %Y %Z')
                            days_until_expiry = (not_after - datetime.now()).days
                            ssl_info["days_until_expiry"] = days_until_expiry
                            ssl_info["expires_soon"] = days_until_expiry < 30
                        except:
                            ssl_info["expires_soon"] = "Unknown"
            else:
                ssl_info["https_enabled"] = False
                ssl_info["vulnerability"] = "Site não usa HTTPS"

        except Exception as e:
            ssl_info["error"] = str(e)
            ssl_info["certificate_valid"] = False

        return ssl_info

    def _analyze_security_headers(self, url):
        """Análise de headers de segurança"""
        security_headers = {}
        try:
            response = self.session.get(url, timeout=10, verify=False)
            headers = response.headers

            # Headers críticos de segurança
            critical_headers = [
                'Strict-Transport-Security',
                'Content-Security-Policy',
                'X-Frame-Options',
                'X-Content-Type-Options',
                'X-XSS-Protection',
                'Referrer-Policy',
                'Permissions-Policy',
                'Cross-Origin-Opener-Policy',
                'Cross-Origin-Embedder-Policy'
            ]

            for header in critical_headers:
                if header in headers:
                    security_headers[header] = {
                        "present": True,
                        "value": headers[header],
                        "secure": self._evaluate_header_security(header, headers[header])
                    }
                else:
                    security_headers[header] = {
                        "present": False,
                        "vulnerability": f"Header {header} ausente"
                    }

            # Verificar headers perigosos
            dangerous_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            security_headers["information_disclosure"] = []

            for header in dangerous_headers:
                if header in headers:
                    security_headers["information_disclosure"].append({
                        "header": header,
                        "value": headers[header],
                        "risk": "Exposição de informações do servidor"
                    })

        except Exception as e:
            security_headers["error"] = str(e)

        return security_headers

    def _evaluate_header_security(self, header_name, header_value):
        """Avaliar se o valor do header é seguro"""
        secure_configs = {
            'Strict-Transport-Security': 'max-age=' in header_value.lower(),
            'Content-Security-Policy': 'unsafe-inline' not in header_value.lower(),
            'X-Frame-Options': header_value.lower() in ['deny', 'sameorigin'],
            'X-Content-Type-Options': header_value.lower() == 'nosniff',
            'X-XSS-Protection': '1; mode=block' in header_value.lower()
        }

        return secure_configs.get(header_name, True)

    def _detect_technologies(self, url):
        """Detecção de tecnologias"""
        technologies = {}
        try:
            response = self.session.get(url, timeout=10, verify=False)
            headers = response.headers
            content = response.text

            # Detecção por headers
            tech_headers = {
                'Server': 'Web Server',
                'X-Powered-By': 'Backend Technology',
                'X-AspNet-Version': 'ASP.NET Version',
                'X-Generator': 'CMS/Framework'
            }

            for header, tech_type in tech_headers.items():
                if header in headers:
                    technologies[tech_type] = headers[header]

            # Detecção por conteúdo
            tech_patterns = {
                'WordPress': r'wp-content|wp-includes|wordpress',
                'Joomla': r'joomla|option=com_',
                'Drupal': r'drupal|sites/default',
                'Laravel': r'laravel_session',
                'Django': r'django|csrfmiddlewaretoken',
                'React': r'react|__REACT_DEVTOOLS',
                'Angular': r'angular|ng-version',
                'Vue.js': r'vue\.js|__vue__',
                'jQuery': r'jquery',
                'Bootstrap': r'bootstrap',
                'PHP': r'\.php',
                'ASP.NET': r'\.aspx?|viewstate',
                'JSP': r'\.jsp|jsessionid'
            }

            technologies["detected_frameworks"] = []
            for tech, pattern in tech_patterns.items():
                if re.search(pattern, content, re.IGNORECASE):
                    technologies["detected_frameworks"].append(tech)

        except Exception as e:
            technologies["error"] = str(e)

        return technologies

    def _detect_cms(self, url):
        """Detecção de CMS e versões"""
        cms_info = {}
        try:
            response = self.session.get(url, timeout=10, verify=False)
            content = response.text

            # Padrões específicos de CMS
            cms_patterns = {
                'WordPress': {
                    'pattern': r'wp-content|wp-includes|wordpress',
                    'version_pattern': r'wp-includes/js/wp-emoji-release\.min\.js\?ver=([0-9.]+)',
                    'admin_path': '/wp-admin/',
                    'config_files': ['/wp-config.php', '/wp-config.php.bak']
                },
                'Joomla': {
                    'pattern': r'joomla|option=com_',
                    'version_pattern': r'generator.*joomla.*([0-9.]+)',
                    'admin_path': '/administrator/',
                    'config_files': ['/configuration.php', '/configuration.php.bak']
                },
                'Drupal': {
                    'pattern': r'drupal|sites/default',
                    'version_pattern': r'drupal ([0-9.]+)',
                    'admin_path': '/admin/',
                    'config_files': ['/sites/default/settings.php']
                }
            }

            for cms, config in cms_patterns.items():
                if re.search(config['pattern'], content, re.IGNORECASE):
                    cms_info[cms] = {
                        'detected': True,
                        'admin_path': config['admin_path']
                    }

                    # Tentar detectar versão
                    version_match = re.search(config['version_pattern'], content, re.IGNORECASE)
                    if version_match:
                        cms_info[cms]['version'] = version_match.group(1)

                    # Verificar arquivos de configuração expostos
                    cms_info[cms]['exposed_configs'] = []
                    for config_file in config['config_files']:
                        try:
                            config_url = urljoin(url, config_file)
                            config_response = self.session.get(config_url, timeout=5, verify=False)
                            if config_response.status_code == 200:
                                cms_info[cms]['exposed_configs'].append(config_file)
                        except:
                            continue

        except Exception as e:
            cms_info["error"] = str(e)

        return cms_info

    def _scan_exposed_files(self, url):
        """Busca por arquivos sensíveis expostos"""
        exposed_files = []

        # Lista de arquivos sensíveis comuns
        sensitive_files = [
            # Arquivos de configuração
            '.env', '.env.local', '.env.production', '.env.backup',
            'config.php', 'config.json', 'settings.py', 'database.yml',
            'wp-config.php', 'wp-config.php.bak', 'configuration.php',

            # Arquivos de backup
            'backup.sql', 'database.sql', 'dump.sql', 'backup.zip',
            'site.zip', 'website.tar.gz', 'backup.tar.gz',

            # Arquivos de log
            'error.log', 'access.log', 'debug.log', 'app.log',

            # Arquivos do sistema
            '.htaccess', '.htpasswd', 'robots.txt', 'sitemap.xml',
            '.git/config', '.git/HEAD', '.svn/entries',

            # Arquivos de desenvolvimento
            'composer.json', 'package.json', 'requirements.txt',
            'Gemfile', 'yarn.lock', 'package-lock.json',

            # Arquivos administrativos
            'admin.php', 'login.php', 'phpmyadmin/', 'adminer.php',
            'test.php', 'info.php', 'phpinfo.php',

            # Documentos sensíveis
            'readme.txt', 'changelog.txt', 'license.txt',
            'installation.txt', 'upgrade.txt'
        ]

        def test_file(file_path):
            try:
                test_url = urljoin(url, file_path)
                response = self.session.get(test_url, timeout=5, verify=False)

                if response.status_code == 200:
                    return {
                        "file": file_path,
                        "url": test_url,
                        "status_code": response.status_code,
                        "size": len(response.content),
                        "content_type": response.headers.get('Content-Type', ''),
                        "risk_level": self._assess_file_risk(file_path, response.content)
                    }
            except:
                pass
            return None

        # Teste paralelo de arquivos
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_file = {executor.submit(test_file, file_path): file_path for file_path in sensitive_files}

            for future in as_completed(future_to_file):
                result = future.result()
                if result:
                    exposed_files.append(result)

        return exposed_files

    def _assess_file_risk(self, file_path, content):
        """Avaliar risco do arquivo exposto"""
        high_risk_patterns = [
            'password', 'secret', 'key', 'token', 'api_key',
            'database', 'mysql', 'postgres', 'mongodb',
            'aws_access_key', 'aws_secret'
        ]

        content_str = content.decode('utf-8', errors='ignore').lower()

        if any(pattern in content_str for pattern in high_risk_patterns):
            return "HIGH"
        elif file_path.startswith('.'):
            return "MEDIUM"
        else:
            return "LOW"

    def _check_directory_listing(self, url):
        """Verificar directory listing"""
        directory_listing = []

        common_dirs = [
            '/', '/admin/', '/uploads/', '/files/', '/images/',
            '/documents/', '/backup/', '/config/', '/includes/',
            '/assets/', '/static/', '/media/', '/tmp/', '/temp/'
        ]

        for directory in common_dirs:
            try:
                dir_url = urljoin(url, directory)
                response = self.session.get(dir_url, timeout=5, verify=False)

                if response.status_code == 200 and 'Index of' in response.text:
                    directory_listing.append({
                        "directory": directory,
                        "url": dir_url,
                        "exposed": True,
                        "risk": "Directory listing habilitado"
                    })
            except:
                continue

        return directory_listing

    def _test_sql_injection(self, url):
        """Teste básico de SQL Injection"""
        sql_vulnerabilities = []

        # Payloads básicos de SQL injection
        sql_payloads = [
            "' OR '1'='1",
            "1' OR '1'='1' --",
            "1' UNION SELECT NULL--",
            "'; DROP TABLE users; --",
            "1' AND 1=1--",
            "1' AND 1=2--"
        ]

        try:
            # Primeiro, fazer uma requisição normal
            response = self.session.get(url, timeout=10, verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')

            # Encontrar formulários
            forms = soup.find_all('form')

            for form in forms:
                action = form.get('action', '')
                method = form.get('method', 'GET').upper()
                form_url = urljoin(url, action)

                # Coletar campos do formulário
                inputs = form.find_all(['input', 'textarea', 'select'])
                form_data = {}

                for input_field in inputs:
                    name = input_field.get('name', '')
                    if name and input_field.get('type', '') not in ['submit', 'button']:
                        form_data[name] = 'test'

                # Testar cada payload
                for payload in sql_payloads:
                    try:
                        test_data = form_data.copy()
                        # Aplicar payload no primeiro campo
                        if test_data:
                            first_field = list(test_data.keys())[0]
                            test_data[first_field] = payload

                            if method == 'POST':
                                test_response = self.session.post(form_url, data=test_data, timeout=5, verify=False)
                            else:
                                test_response = self.session.get(form_url, params=test_data, timeout=5, verify=False)

                            # Verificar sinais de SQL injection
                            error_patterns = [
                                'sql syntax', 'mysql error', 'ora-', 'microsoft ole db',
                                'postgresql error', 'sqlite error', 'sql server'
                            ]

                            if any(pattern in test_response.text.lower() for pattern in error_patterns):
                                sql_vulnerabilities.append({
                                    "form_url": form_url,
                                    "method": method,
                                    "vulnerable_parameter": first_field,
                                    "payload": payload,
                                    "risk": "HIGH - Possível SQL Injection"
                                })
                                break
                    except:
                        continue

        except Exception as e:
            sql_vulnerabilities.append({"error": str(e)})

        return sql_vulnerabilities

    def _test_xss(self, url):
        """Teste básico de XSS"""
        xss_vulnerabilities = []

        # Payloads básicos de XSS
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//"
        ]

        try:
            response = self.session.get(url, timeout=10, verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')

            # Encontrar formulários
            forms = soup.find_all('form')

            for form in forms:
                action = form.get('action', '')
                method = form.get('method', 'GET').upper()
                form_url = urljoin(url, action)

                inputs = form.find_all(['input', 'textarea'])

                for input_field in inputs:
                    name = input_field.get('name', '')
                    input_type = input_field.get('type', 'text')

                    if name and input_type in ['text', 'search', 'url', 'email']:
                        for payload in xss_payloads:
                            try:
                                test_data = {name: payload}

                                if method == 'POST':
                                    test_response = self.session.post(form_url, data=test_data, timeout=5, verify=False)
                                else:
                                    test_response = self.session.get(form_url, params=test_data, timeout=5, verify=False)

                                # Verificar se o payload aparece no response
                                if payload in test_response.text:
                                    xss_vulnerabilities.append({
                                        "form_url": form_url,
                                        "method": method,
                                        "vulnerable_parameter": name,
                                        "payload": payload,
                                        "risk": "MEDIUM - Possível XSS Reflected"
                                    })
                                    break
                            except:
                                continue

        except Exception as e:
            xss_vulnerabilities.append({"error": str(e)})

        return xss_vulnerabilities

    def _test_csrf(self, url):
        """Teste básico de CSRF"""
        csrf_vulnerabilities = []

        try:
            response = self.session.get(url, timeout=10, verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')

            # Encontrar formulários
            forms = soup.find_all('form')

            for form in forms:
                method = form.get('method', 'GET').upper()

                if method == 'POST':
                    # Verificar se existe token CSRF
                    csrf_tokens = form.find_all('input', {'name': re.compile(r'csrf|token|_token', re.I)})

                    if not csrf_tokens:
                        action = form.get('action', '')
                        form_url = urljoin(url, action)

                        csrf_vulnerabilities.append({
                            "form_url": form_url,
                            "method": method,
                            "risk": "MEDIUM - Formulário POST sem proteção CSRF",
                            "description": "Formulário não possui token CSRF"
                        })

        except Exception as e:
            csrf_vulnerabilities.append({"error": str(e)})

        return csrf_vulnerabilities

    def _scan_admin_panels(self, url):
        """Busca por painéis administrativos"""
        admin_panels = []

        # Caminhos comuns de admin
        admin_paths = [
            '/admin/', '/administrator/', '/admin.php', '/login.php',
            '/wp-admin/', '/wp-login.php', '/adminpanel/', '/control/',
            '/cpanel/', '/manager/', '/dashboard/', '/backend/',
            '/admin/login/', '/admin/index.php', '/admin/admin.php',
            '/phpmyadmin/', '/pma/', '/adminer.php', '/mysql/',
            '/webmail/', '/mail/', '/email/', '/roundcube/'
        ]

        def test_admin_path(path):
            try:
                admin_url = urljoin(url, path)
                response = self.session.get(admin_url, timeout=5, verify=False)

                if response.status_code == 200:
                    # Verificar se é realmente um painel admin
                    admin_indicators = [
                        'login', 'password', 'username', 'admin', 'dashboard',
                        'control panel', 'administration', 'sign in'
                    ]

                    content_lower = response.text.lower()
                    if any(indicator in content_lower for indicator in admin_indicators):
                        return {
                            "path": path,
                            "url": admin_url,
                            "status_code": response.status_code,
                            "risk": "MEDIUM - Painel administrativo acessível",
                            "title": BeautifulSoup(response.text, 'html.parser').title.string if BeautifulSoup(response.text, 'html.parser').title else "N/A"
                        }
                elif response.status_code == 401:
                    return {
                        "path": path,
                        "url": admin_url,
                        "status_code": response.status_code,
                        "risk": "LOW - Painel protegido por autenticação",
                        "auth_required": True
                    }
            except:
                pass
            return None

        # Teste paralelo
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_path = {executor.submit(test_admin_path, path): path for path in admin_paths}

            for future in as_completed(future_to_path):
                result = future.result()
                if result:
                    admin_panels.append(result)

        return admin_panels

    def _discover_api_endpoints(self, url):
        """Descoberta de endpoints de API"""
        api_endpoints = []

        # Caminhos comuns de API
        api_paths = [
            '/api/', '/api/v1/', '/api/v2/', '/v1/', '/v2/',
            '/rest/', '/rest/api/', '/webservice/', '/ws/',
            '/graphql/', '/graph/', '/query/', '/api.php',
            '/api.json', '/api/users/', '/api/auth/', '/api/login/',
            '/api/status/', '/api/health/', '/api/docs/'
        ]

        try:
            # Primeiro, buscar referencias de API no JavaScript
            response = self.session.get(url, timeout=10, verify=False)
            soup = BeautifulSoup(response.text, 'html.parser')

            # Analisar scripts
            scripts = soup.find_all('script')
            js_content = ""

            for script in scripts:
                if script.string:
                    js_content += script.string
                elif script.get('src'):
                    try:
                        js_url = urljoin(url, script['src'])
                        js_response = self.session.get(js_url, timeout=5, verify=False)
                        js_content += js_response.text
                    except:
                        pass

            # Buscar endpoints de API no JavaScript
            api_patterns = [
                r'["\']\/api\/[^"\']*["\']',
                r'["\']\/v\d+\/[^"\']*["\']',
                r'fetch\(["\']([^"\']*\/api\/[^"\']*)["\']',
                r'axios\.[a-z]+\(["\']([^"\']*\/api\/[^"\']*)["\']'
            ]

            for pattern in api_patterns:
                matches = re.findall(pattern, js_content, re.IGNORECASE)
                for match in matches:
                    endpoint = match if isinstance(match, str) else match[0]
                    if endpoint and '/api/' in endpoint:
                        api_endpoints.append({
                            "endpoint": endpoint,
                            "source": "JavaScript analysis",
                            "method": "unknown"
                        })

            # Testar caminhos comuns
            for path in api_paths:
                try:
                    api_url = urljoin(url, path)
                    response = self.session.get(api_url, timeout=5, verify=False)

                    if response.status_code == 200:
                        content_type = response.headers.get('Content-Type', '').lower()

                        if 'json' in content_type or 'api' in response.text.lower():
                            api_endpoints.append({
                                "endpoint": path,
                                "url": api_url,
                                "status_code": response.status_code,
                                "content_type": content_type,
                                "source": "Path discovery"
                            })
                except:
                    continue

        except Exception as e:
            api_endpoints.append({"error": str(e)})

        return api_endpoints

    def _scan_sensitive_data(self, url):
        """Busca por dados sensíveis expostos"""
        sensitive_data = []

        try:
            response = self.session.get(url, timeout=10, verify=False)
            content = response.text

            # Padrões de dados sensíveis
            sensitive_patterns = [
                (r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}', "Email Address"),
                (r'\b\d{3}-\d{2}-\d{4}\b', "SSN"),
                (r'\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b', "Credit Card"),
                (r'(?i)password\s*[:=]\s*["\']([^"\']{6,})["\']', "Password"),
                (r'(?i)api[_-]?key\s*[:=]\s*["\']([^"\']+)["\']', "API Key"),
                (r'(?i)secret\s*[:=]\s*["\']([^"\']+)["\']', "Secret"),
                (r'(?i)token\s*[:=]\s*["\']([^"\']+)["\']', "Token"),
                (r'\b\d{3}[\.-]?\d{3}[\.-]?\d{4}\b', "Phone Number"),
                (r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', "IP Address")
            ]

            for pattern, data_type in sensitive_patterns:
                matches = re.findall(pattern, content)
                if matches:
                    for match in matches[:5]:  # Limitar a 5 matches por tipo
                        sensitive_data.append({
                            "type": data_type,
                            "value": match if isinstance(match, str) else match[0],
                            "risk": "HIGH" if data_type in ["Password", "API Key", "Secret", "Token"] else "MEDIUM"
                        })

        except Exception as e:
            sensitive_data.append({"error": str(e)})

        return sensitive_data

    def _scan_common_ports(self, url):
        """Scan de portas comuns (limitado)"""
        port_scan = []

        try:
            parsed = urlparse(url)
            hostname = parsed.netloc.split(':')[0]

            # Portas comuns para verificar
            common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5432, 3306, 27017, 6379]

            def scan_port(port):
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(3)
                    result = sock.connect_ex((hostname, port))
                    sock.close()

                    if result == 0:
                        return {
                            "port": port,
                            "status": "open",
                            "service": self._get_service_name(port),
                            "risk": self._assess_port_risk(port)
                        }
                except:
                    pass
                return None

            # Scan paralelo (limitado para não sobrecarregar)
            with ThreadPoolExecutor(max_workers=5) as executor:
                future_to_port = {executor.submit(scan_port, port): port for port in common_ports}

                for future in as_completed(future_to_port):
                    result = future.result()
                    if result:
                        port_scan.append(result)

        except Exception as e:
            port_scan.append({"error": str(e)})

        return port_scan

    def _get_service_name(self, port):
        """Obter nome do serviço por porta"""
        services = {
            21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS",
            80: "HTTP", 110: "POP3", 143: "IMAP", 443: "HTTPS",
            993: "IMAPS", 995: "POP3S", 3389: "RDP", 5432: "PostgreSQL",
            3306: "MySQL", 27017: "MongoDB", 6379: "Redis"
        }
        return services.get(port, "Unknown")

    def _assess_port_risk(self, port):
        """Avaliar risco da porta aberta"""
        high_risk_ports = [21, 22, 23, 3389, 3306, 5432, 27017, 6379]
        medium_risk_ports = [25, 110, 143]

        if port in high_risk_ports:
            return "HIGH"
        elif port in medium_risk_ports:
            return "MEDIUM"
        else:
            return "LOW"

    def _calculate_risk_score(self, results):
        """Calcular score de risco geral"""
        score = 0
        summary = {}

        # SSL/TLS issues
        ssl_analysis = results.get("ssl_analysis", {})
        if not ssl_analysis.get("certificate_valid", True):
            score += 20
        if ssl_analysis.get("expires_soon"):
            score += 10

        # Security headers
        security_headers = results.get("security_headers", {})
        missing_headers = sum(1 for header_info in security_headers.values() 
                             if isinstance(header_info, dict) and not header_info.get("present", True))
        score += missing_headers * 5

        # Exposed files
        exposed_files = results.get("exposed_files", [])
        high_risk_files = sum(1 for file_info in exposed_files if file_info.get("risk_level") == "HIGH")
        score += high_risk_files * 15
        score += (len(exposed_files) - high_risk_files) * 5

        # Vulnerabilities
        sql_injection = results.get("sql_injection", [])
        score += len([v for v in sql_injection if isinstance(v, dict) and "error" not in v]) * 25

        xss_vulnerabilities = results.get("xss_vulnerabilities", [])
        score += len([v for v in xss_vulnerabilities if isinstance(v, dict) and "error" not in v]) * 15

        csrf_vulnerabilities = results.get("csrf_vulnerabilities", [])
        score += len([v for v in csrf_vulnerabilities if isinstance(v, dict) and "error" not in v]) * 10

        # Admin panels
        admin_panels = results.get("admin_panels", [])
        score += len(admin_panels) * 8

        # Open ports
        port_scan = results.get("port_scan", [])
        high_risk_ports = sum(1 for port_info in port_scan if port_info.get("risk") == "HIGH")
        score += high_risk_ports * 12

        # Sensitive data
        sensitive_data = results.get("sensitive_data", [])
        high_risk_data = sum(1 for data in sensitive_data if data.get("risk") == "HIGH")
        score += high_risk_data * 20

        # Limitar score a 100
        score = min(score, 100)

        # Classificar risco
        if score >= 70:
            risk_level = "CRITICAL"
        elif score >= 50:
            risk_level = "HIGH"
        elif score >= 30:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"

        summary = {
            "total_vulnerabilities": len(sql_injection) + len(xss_vulnerabilities) + len(csrf_vulnerabilities),
            "exposed_files_count": len(exposed_files),
            "admin_panels_count": len(admin_panels),
            "open_ports_count": len(port_scan),
            "risk_level": risk_level
        }

        return score, summary

    def _generate_recommendations(self, results):
        """Gerar recomendações de segurança"""
        recommendations = []

        # SSL/TLS
        ssl_analysis = results.get("ssl_analysis", {})
        if not ssl_analysis.get("certificate_valid", True):
            recommendations.append({
                "category": "SSL/TLS",
                "priority": "HIGH",
                "recommendation": "Configurar certificado SSL válido e forçar HTTPS"
            })

        # Security headers
        security_headers = results.get("security_headers", {})
        for header, info in security_headers.items():
            if isinstance(info, dict) and not info.get("present", True):
                recommendations.append({
                    "category": "Security Headers",
                    "priority": "MEDIUM",
                    "recommendation": f"Implementar header de segurança: {header}"
                })

        # Exposed files
        exposed_files = results.get("exposed_files", [])
        if exposed_files:
            recommendations.append({
                "category": "File Exposure",
                "priority": "HIGH",
                "recommendation": f"Remover ou proteger {len(exposed_files)} arquivo(s) sensível(is) exposto(s)"
            })

        # Vulnerabilities
        sql_injection = results.get("sql_injection", [])
        if sql_injection:
            recommendations.append({
                "category": "SQL Injection",
                "priority": "CRITICAL",
                "recommendation": "Corrigir vulnerabilidades de SQL Injection encontradas"
            })

        xss_vulnerabilities = results.get("xss_vulnerabilities", [])
        if xss_vulnerabilities:
            recommendations.append({
                "category": "XSS",
                "priority": "HIGH",
                "recommendation": "Implementar validação e escape de entrada para prevenir XSS"
            })

        csrf_vulnerabilities = results.get("csrf_vulnerabilities", [])
        if csrf_vulnerabilities:
            recommendations.append({
                "category": "CSRF",
                "priority": "MEDIUM",
                "recommendation": "Implementar tokens CSRF em formulários"
            })

        # Admin panels
        admin_panels = results.get("admin_panels", [])
        if admin_panels:
            recommendations.append({
                "category": "Access Control",
                "priority": "MEDIUM",
                "recommendation": "Proteger painéis administrativos com autenticação forte"
            })

        # Open ports
        port_scan = results.get("port_scan", [])
        high_risk_ports = [port for port in port_scan if port.get("risk") == "HIGH"]
        if high_risk_ports:
            recommendations.append({
                "category": "Network Security",
                "priority": "HIGH",
                "recommendation": f"Fechar ou proteger {len(high_risk_ports)} porta(s) de alto risco"
            })

        return recommendations

    def generate_report(self, results, output_file=None):
        """Gerar relatório completo em HTML"""
        if not output_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            domain = urlparse(results["target_url"]).netloc.replace(".", "_")
            output_file = f"vulnerability_report_{domain}_{timestamp}.html"

        html_content = f"""
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relatório de Vulnerabilidades - {results['target_url']}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; padding: 20px; }}
        .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; margin-bottom: 2rem; }}
        .header h1 {{ font-size: 2.5rem; margin-bottom: 0.5rem; }}
        .header p {{ font-size: 1.1rem; opacity: 0.9; }}
        .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 2rem; }}
        .summary-card {{ background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); text-align: center; }}
        .summary-card h3 {{ color: #333; margin-bottom: 0.5rem; }}
        .summary-card .number {{ font-size: 2rem; font-weight: bold; margin-bottom: 0.5rem; }}
        .critical {{ color: #e74c3c; }}
        .high {{ color: #e67e22; }}
        .medium {{ color: #f39c12; }}
        .low {{ color: #27ae60; }}
        .section {{ background: white; margin-bottom: 2rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden; }}
        .section-header {{ background: #34495e; color: white; padding: 1rem; font-size: 1.2rem; font-weight: bold; }}
        .section-content {{ padding: 1.5rem; }}
        .vulnerability {{ border-left: 4px solid; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; }}
        .vulnerability.critical {{ border-color: #e74c3c; background: #fdf2f2; }}
        .vulnerability.high {{ border-color: #e67e22; background: #fef9e7; }}
        .vulnerability.medium {{ border-color: #f39c12; background: #fffaf0; }}
        .vulnerability.low {{ border-color: #27ae60; background: #f0fff4; }}
        .table {{ width: 100%; border-collapse: collapse; margin-top: 1rem; }}
        .table th, .table td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        .table th {{ background: #f8f9fa; font-weight: bold; }}
        .badge {{ padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold; text-transform: uppercase; }}
        .badge.critical {{ background: #e74c3c; color: white; }}
        .badge.high {{ background: #e67e22; color: white; }}
        .badge.medium {{ background: #f39c12; color: white; }}
        .badge.low {{ background: #27ae60; color: white; }}
        .recommendation {{ background: #e8f4f8; border: 1px solid #b8dae4; padding: 1rem; margin: 0.5rem 0; border-radius: 4px; }}
        .code {{ background: #f8f9fa; border: 1px solid #e9ecef; padding: 0.5rem; border-radius: 4px; font-family: monospace; }}
        .footer {{ text-align: center; padding: 2rem; color: #666; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🛡️ Relatório de Vulnerabilidades</h1>
            <p><strong>Alvo:</strong> {results['target_url']}</p>
            <p><strong>Data da Varredura:</strong> {results['scan_timestamp']}</p>
            <p><strong>Score de Risco:</strong> {results['risk_score']}/100 ({results['vulnerability_summary']['risk_level']})</p>
        </div>

        <div class="summary">
            <div class="summary-card">
                <h3>Vulnerabilidades</h3>
                <div class="number critical">{results['vulnerability_summary']['total_vulnerabilities']}</div>
                <p>Encontradas</p>
            </div>
            <div class="summary-card">
                <h3>Arquivos Expostos</h3>
                <div class="number high">{results['vulnerability_summary']['exposed_files_count']}</div>
                <p>Arquivos Sensíveis</p>
            </div>
            <div class="summary-card">
                <h3>Painéis Admin</h3>
                <div class="number medium">{results['vulnerability_summary']['admin_panels_count']}</div>
                <p>Descobertos</p>
            </div>
            <div class="summary-card">
                <h3>Portas Abertas</h3>
                <div class="number low">{results['vulnerability_summary']['open_ports_count']}</div>
                <p>Portas</p>
            </div>
        </div>
"""

        # Seção SSL/TLS
        if results.get('ssl_analysis'):
            html_content += """
        <div class="section">
            <div class="section-header">🔒 Análise SSL/TLS</div>
            <div class="section-content">
"""
            ssl_info = results['ssl_analysis']
            if ssl_info.get('certificate_valid'):
                html_content += f"""
                <p><strong>✅ Certificado:</strong> Válido</p>
                <p><strong>Emissor:</strong> {ssl_info.get('issuer', {}).get('organizationName', 'N/A')}</p>
                <p><strong>Protocolo:</strong> {ssl_info.get('protocol', 'N/A')}</p>
                <p><strong>Válido até:</strong> {ssl_info.get('not_after', 'N/A')}</p>
"""
                if ssl_info.get('expires_soon'):
                    html_content += '<div class="vulnerability medium"><strong>⚠️ Atenção:</strong> Certificado expira em breve!</div>'
            else:
                html_content += '<div class="vulnerability critical"><strong>❌ Certificado SSL inválido ou ausente</strong></div>'

            html_content += "</div></div>"

        # Seção Security Headers
        if results.get('security_headers'):
            html_content += """
        <div class="section">
            <div class="section-header">🛡️ Headers de Segurança</div>
            <div class="section-content">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Header</th>
                            <th>Status</th>
                            <th>Valor</th>
                        </tr>
                    </thead>
                    <tbody>
"""
            for header, info in results['security_headers'].items():
                if isinstance(info, dict):
                    status = "✅ Presente" if info.get('present') else "❌ Ausente"
                    status_class = "low" if info.get('present') else "high"
                    value = info.get('value', 'N/A')
                    html_content += f"""
                        <tr>
                            <td><strong>{header}</strong></td>
                            <td><span class="badge {status_class}">{status}</span></td>
                            <td class="code">{value}</td>
                        </tr>
"""
            html_content += "</tbody></table></div></div>"

        # Seção Vulnerabilidades
        if results.get('sql_injection') or results.get('xss_vulnerabilities') or results.get('csrf_vulnerabilities'):
            html_content += """
        <div class="section">
            <div class="section-header">🚨 Vulnerabilidades Críticas</div>
            <div class="section-content">
"""

            # SQL Injection
            for vuln in results.get('sql_injection', []):
                if isinstance(vuln, dict) and 'error' not in vuln:
                    html_content += f"""
                <div class="vulnerability critical">
                    <h4>🔴 SQL Injection</h4>
                    <p><strong>URL:</strong> {vuln.get('form_url', 'N/A')}</p>
                    <p><strong>Parâmetro:</strong> {vuln.get('vulnerable_parameter', 'N/A')}</p>
                    <p><strong>Payload:</strong> <code>{vuln.get('payload', 'N/A')}</code></p>
                </div>
"""

            # XSS
            for vuln in results.get('xss_vulnerabilities', []):
                if isinstance(vuln, dict) and 'error' not in vuln:
                    html_content += f"""
                <div class="vulnerability high">
                    <h4>🟠 Cross-Site Scripting (XSS)</h4>
                    <p><strong>URL:</strong> {vuln.get('form_url', 'N/A')}</p>
                    <p><strong>Parâmetro:</strong> {vuln.get('vulnerable_parameter', 'N/A')}</p>
                    <p><strong>Payload:</strong> <code>{vuln.get('payload', 'N/A')}</code></p>
                </div>
"""

            # CSRF
            for vuln in results.get('csrf_vulnerabilities', []):
                if isinstance(vuln, dict) and 'error' not in vuln:
                    html_content += f"""
                <div class="vulnerability medium">
                    <h4>🟡 Cross-Site Request Forgery (CSRF)</h4>
                    <p><strong>URL:</strong> {vuln.get('form_url', 'N/A')}</p>
                    <p><strong>Descrição:</strong> {vuln.get('description', 'N/A')}</p>
                </div>
"""

            html_content += "</div></div>"

        # Seção Arquivos Expostos
        if results.get('exposed_files'):
            html_content += """
        <div class="section">
            <div class="section-header">📁 Arquivos Sensíveis Expostos</div>
            <div class="section-content">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Arquivo</th>
                            <th>Risco</th>
                            <th>Tamanho</th>
                            <th>URL</th>
                        </tr>
                    </thead>
                    <tbody>
"""
            for file_info in results['exposed_files']:
                risk_class = file_info.get('risk_level', 'LOW').lower()
                html_content += f"""
                    <tr>
                        <td><strong>{file_info.get('file', 'N/A')}</strong></td>
                        <td><span class="badge {risk_class}">{file_info.get('risk_level', 'LOW')}</span></td>
                        <td>{file_info.get('size', 0)} bytes</td>
                        <td><a href="{file_info.get('url', '#')}" target="_blank">Acessar</a></td>
                    </tr>
"""
            html_content += "</tbody></table></div></div>"

        # Seção Recomendações
        if results.get('recommendations'):
            html_content += """
        <div class="section">
            <div class="section-header">💡 Recomendações de Segurança</div>
            <div class="section-content">
"""
            for rec in results['recommendations']:
                priority_class = rec.get('priority', 'LOW').lower()
                html_content += f"""
                <div class="recommendation">
                    <h4><span class="badge {priority_class}">{rec.get('priority', 'LOW')}</span> {rec.get('category', 'Geral')}</h4>
                    <p>{rec.get('recommendation', 'N/A')}</p>
                </div>
"""
            html_content += "</div></div>"

        # Footer
        html_content += f"""
        <div class="footer">
            <p>🤖 Relatório gerado pelo Catalyst Server - Vulnerability Scanner v1.0</p>
            <p>Data de geração: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}</p>
        </div>
    </div>
</body>
</html>
"""

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

        return output_file

# Função principal para uso no bot
def scan_vulnerabilities_comprehensive(url):
    """Função principal para varredura completa de vulnerabilidades"""
    scanner = ProfessionalVulnerabilityScanner()
    return scanner.comprehensive_vulnerability_scan(url)

def generate_vulnerability_report(results, output_file=None):
    """Gerar relatório de vulnerabilidades"""
    scanner = ProfessionalVulnerabilityScanner()
    return scanner.generate_report(results, output_file)

# Exemplo de uso
if __name__ == "__main__":
    url = input("Digite a URL para varredura de vulnerabilidades: ")

    print("🔍 Iniciando varredura completa de vulnerabilidades...")
    scanner = ProfessionalVulnerabilityScanner()
    results = scanner.comprehensive_vulnerability_scan(url)

    if "error" in results:
        print(f"❌ Erro: {results['error']}")
    else:
        print("\n" + "="*80)
        print("🛡️ RELATÓRIO DE VULNERABILIDADES")
        print("="*80)

        print(f"\n🎯 Site analisado: {results['target_url']}")
        print(f"⏰ Varredura realizada em: {results['scan_timestamp']}")
        print(f"📊 Score de risco: {results['risk_score']}/100 ({results['vulnerability_summary']['risk_level']})")

        # Gerar relatório HTML
        report_file = scanner.generate_report(results)
        print(f"\n📄 Relatório HTML gerado: {report_file}")

        print(f"\n✅ Varredura concluída!")
